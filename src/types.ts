/**
 * Core type definitions for RCA Agent
 * 
 * This file contains all shared interfaces and types used throughout the system.
 * Following single source of truth principle for type definitions.
 */

/**
 * Parsed error information extracted from error text
 */
export interface ParsedError {
  /** Type of error (e.g., 'lateinit', 'npe', 'build') */
  type: string;
  
  /** Full error message */
  message: string;
  
  /** File where error occurred */
  filePath: string;
  
  /** Line number where error occurred (1-indexed) */
  line: number;
  
  /** Programming language */
  language: 'kotlin' | 'java' | 'xml' | 'gradle';
  
  /** Optional: Column number */
  column?: number;
  
  /** Optional: Stack trace frames */
  stackTrace?: StackFrame[];
  
  /** Optional: Additional metadata specific to error type */
  metadata?: Record<string, any>;
}

/**
 * Stack trace frame information
 */
export interface StackFrame {
  /** File path */
  file: string;
  
  /** Line number */
  line: number;
  
  /** Function/method name */
  function?: string;
  
  /** Class name */
  className?: string;
}

/**
 * Root Cause Analysis result
 */
export interface RCAResult {
  /** Original error message */
  error: string;
  
  /** Identified root cause */
  rootCause: string;
  
  /** Step-by-step fix guidelines */
  fixGuidelines: string[];
  
  /** Confidence score (0-1) */
  confidence: number;
  
  /** Optional: Related code snippets */
  codeContext?: string;
  
  /** Optional: Similar past errors */
  similarErrors?: string[];
}

/**
 * Agent state during analysis
 * Used for tracking progress and enabling checkpoint/resume
 */
export interface AgentState {
  /** Current iteration number */
  iteration: number;
  
  /** Maximum iterations allowed */
  maxIterations: number;
  
  /** Start time (timestamp) */
  startTime: number;
  
  /** Timeout in milliseconds */
  timeout: number;
  
  /** Analysis mode */
  mode: 'standard' | 'educational' | 'fast';
  
  /** Thoughts generated by agent */
  thoughts: string[];
  
  /** Actions taken (tool calls) */
  actions: ToolCall[];
  
  /** Observations from tool executions */
  observations: string[];
  
  /** Current hypothesis */
  hypothesis: string | null;
  
  /** Identified root cause */
  rootCause: string | null;
  
  /** Whether analysis has converged */
  converged: boolean;
  
  /** Error being analyzed */
  error: ParsedError;
  
  /** Optional: File content at error location (added in Chunk 1.4) */
  fileContent?: string | null;
}

/**
 * Tool call made by agent
 */
export interface ToolCall {
  /** Tool name */
  tool: string;
  
  /** Parameters passed to tool */
  parameters: Record<string, any>;
  
  /** Timestamp when tool was called */
  timestamp: number;
  
  /** Optional: Result of tool execution */
  result?: any;
  
  /** Optional: Error if tool failed */
  error?: string;
}

/**
 * LLM generation options
 */
export interface GenerateOptions {
  /** Temperature for randomness (0-1) */
  temperature?: number;
  
  /** Maximum tokens to generate */
  maxTokens?: number;
  
  /** Stop sequences */
  stop?: string[];
  
  /** Top-p sampling */
  topP?: number;
  
  /** Top-k sampling */
  topK?: number;
}

/**
 * LLM response
 */
export interface LLMResponse {
  /** Generated text */
  text: string;
  
  /** Tokens used */
  tokensUsed?: number;
  
  /** Generation time in milliseconds */
  generationTime?: number;
  
  /** Model used */
  model?: string;
}

/**
 * Error thrown when parsing fails
 */
export class ParsingError extends Error {
  constructor(
    message: string,
    public readonly errorText: string,
    public readonly language: string
  ) {
    super(message);
    this.name = 'ParsingError';
  }
}

/**
 * Error thrown when LLM operation fails
 */
export class LLMError extends Error {
  constructor(
    message: string,
    public readonly statusCode?: number,
    public readonly retryable: boolean = true
  ) {
    super(message);
    this.name = 'LLMError';
  }
}

/**
 * Error thrown when analysis times out
 */
export class AnalysisTimeoutError extends Error {
  constructor(
    message: string,
    public readonly iteration: number,
    public readonly maxIterations: number
  ) {
    super(message);
    this.name = 'AnalysisTimeoutError';
  }
}

/**
 * Error thrown when input validation fails
 */
export class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}
